import pygame
from time import sleep
import random
from math import cos,sin,pi
DISP_WIDTH = 800
DISP_HEIGHT = 600
 
class Player:
'''models a moving player representation that can move left or right'''
BASECOLOR = pygame.Color('darkred')
BASE_SPEED = 2.
SIZE = 16
 
def __init__(self, x_init, y_init):
self.vx, self.vy = 0.,0.
self.x,self.y = float(x_init), float(y_init)
self.color= Player.BASECOLOR
self.moving_left = self.moving_right = False
 
def markToDisplay(self, surface):
pygame.draw.circle( surface, self.color, (int(self.x),int(self.y)), Player.SIZE)
 
def startMovingRight(self):
self.moving_right = True
 
def startMovingLeft(self):
self.moving_left = True
 
def stopMoving(self):
if( self.moving_right):
self.moving_right= False
if( self.moving_left):
self.moving_left= False
terrain.stopScroll()
 
def updatePosition( self ):
if not (self.moving_right or self.moving_left):
self.vx = 0.
else:
if self.moving_right:
self.vx = Player.BASE_SPEED
if self.moving_left:
self.vx = -Player.BASE_SPEED
#scrolling
if( self.x+self.vx> (2./3)*DISP_WIDTH ):
if( not terrain.isScrolling()):
terrain.startScrollLeft() # scroll in the inverse direction of player mov. to make it happen
self.stuck = True
elif( self.x+self.vx< (1./3)*DISP_WIDTH ):
if( not terrain.isScrolling()):
terrain.startScrollRight()
self.stuck = True
else:
self.stuck = False
 
if(not self.stuck):
self.x += self.vx
self.y = int( DISP_HEIGHT - terrain.l_heights[ int(self.x) ] - Player.SIZE )
 
class Terrain:
def __init__(self):
self.dist = 0
self.det_h_fct= \
lambda k: 228. + ( \
128.0 *cos(0.0002 *k) + 32. * sin(0.01 * k) + 16.* abs( sin(0.02 *k + (pi/2) ) ) + 64.*sin( pi/800 * k ) )
 
self.l_heights = list()
for i in xrange(DISP_WIDTH ):
self.l_heights.append( self.det_h_fct(i) )
self.color = pygame.Color('darkgreen')
self.moving_right = self.moving_left = False
 
def isScrolling( self):
return ( self.moving_right or self.moving_left )
 
def startScrollRight(self):
self.moving_right = True
 
def startScrollLeft(self):
self.moving_left = True
 
def stopScroll(self):
self.moving_left = self.moving_right = False
 
def update(self):
#refresh terrain heights
if (self.moving_right):
self.dist-= 1
self.l_heights.pop()
self.l_heights.insert(0, self.det_h_fct( self.dist ) )
self.dist-= 1
self.l_heights.pop()
self.l_heights.insert(0, self.det_h_fct( self.dist ) )
if (self.moving_left):
self.dist+=1
self.l_heights.pop(0)
self.l_heights.append( self.det_h_fct( self.dist+DISP_WIDTH-1 ) )
self.dist+=1
self.l_heights.pop(0)
self.l_heights.append( self.det_h_fct( self.dist+DISP_WIDTH-1 ) )
 
def markToDisplay(self, surface):
for ind in xrange(len(self.l_heights) ):
h_val = self.l_heights[ ind]
pygame.draw.line( surface, self.color,
(ind, DISP_HEIGHT-1), (ind, DISP_HEIGHT-1-h_val), )
 
def refreshScreen():
window.fill( pygame.Color('lightblue') )
terrain.markToDisplay(window)
pl_obj.markToDisplay(window )
pygame.display.flip()
 
# init. pygame libr; create the screen and diplays a help message in the console
pygame.init()
window = pygame.display.set_mode( (DISP_WIDTH, DISP_HEIGHT) )
pl_obj = Player( DISP_WIDTH/2, DISP_HEIGHT/2 )
terrain = Terrain()
 
program_done = False
while not program_done:
refreshScreen()
for event in pygame.event.get():
if event.type == pygame.QUIT:
program_done = True
break
 
if event.type is pygame.KEYDOWN:
if( pygame.key.get_pressed()[ pygame.K_RIGHT ] ):
pl_obj.startMovingRight()
if( pygame.key.get_pressed()[ pygame.K_LEFT ] ):
pl_obj.startMovingLeft()
if event.type is pygame.KEYUP:
if( not pygame.key.get_pressed()[ pygame.K_RIGHT ] ):
pl_obj.stopMoving()
if( not pygame.key.get_pressed()[ pygame.K_LEFT ] ):
pl_obj.stopMoving()
pl_obj.updatePosition()
terrain.update()
